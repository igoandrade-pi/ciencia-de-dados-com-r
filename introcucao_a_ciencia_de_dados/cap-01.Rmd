---
title: "Introdução ao R e ao RStudio"
author: "Igo da Costa Andrade"
date: "`r Sys.Date()`"
output: 
  pdf_document:
    extra_dependencies: ["enumitem", "xcolor"]
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
options(scipen=999)
```

## 2.11 Exercícios

\begin{enumerate}[leftmargin=*]
  \item Qual é a soma dos primeiros 100 números inteiros positivos? A fórmula para a soma dos inteiros de 1 até $n$  é $n \left(n+1\right)/2$. Defina $n = 100$ e então use \verb|R| para calcular a soma de 1 até 100 usando a fórmula. Qual é a soma?
  
\end{enumerate}
  
```{r}
n <- 100

soma = n * (n+1) / 2

```

\begin{enumerate}[resume, leftmargin=*]

\item[] \textbf{Resposta}: A soma dos primeiros `r n` inteiros positivos é `r soma`. 


\item Agora use a mesma fórmula para calcular a soma dos inteiros de 1 a 1000.

\end{enumerate}


```{r}
n <- 1000
soma = n * (n+1) / 2
```

\begin{enumerate}[resume, leftmargin=*]

\item[] \textbf{Resposta}: A soma dos primeiros `r n` inteiros positivos é `r soma`. 

\item Observe o resultado da digitação do seguinte códico em \verb|R|:


\end{enumerate}


```{r}
n <- 1000
x <- seq(1, n)
sum(x)
```


\begin{enumerate}[resume, leftmargin=*]
\item[] Com base no resultado, o que você acha que as funções \verb|seq| e \verb|sum| fazem? 

  \begin{enumerate}[label=\alph*.]
    \item \verb|sum| cria uma lista de números e \verb|seq| os soma.
    {\color{red} \item \verb|seq| cria uma lista de números e \verb|sum| os soma.}
    \item \verb|seq| cria uma lista aleatória e \verb|sum| calcula a soma de 1 a 1.000.
    \item \verb|sum| sempre retorna o mesmo número.
  \end{enumerate}
  
  \item Em matemática e programação, dizemos que avaliamos uma função quando substituimos o argumento por um determinado número. Então, se digitarmos \verb|sqrt(4)|, avaliaremos a função \verb|sqrt|. Em \verb|R|, você pode avaliar uma função dentro de outra função. As avaliações acontecem de dendro para fora. Use uma linha de código para calcular o logarítmo, na base 10, da raiz quadrada de 100.
\end{enumerate} 

```{r}
log(sqrt(100), base=10)
```

\begin{enumerate}[resume, leftmargin=*]
\item  Qual das opções a seguir sempre retornará o valor numérico armazenado em \verb|x|?

  \begin{enumerate}[label=\alph*.]
    \item \verb|log(10^x)|
    \item \verb|log10(x^10)|
    {\color{red} \item \verb|log(exp(x))|}
    \item \verb|log(x, base=2)|
  \end{enumerate}
  
  \item Certifique-se de que o conjunto de dados de assassinatos nos EUA esteja carregado. Use a função \verb|str| para examinar a estrutura do ibjeto \verb|murder|. Qual das alternativas a seguir descreve melhor as variáveis representadas neste \textit{data frame}.
  
  \begin{enumerate}[label=\alph*.]
    \item Os 51 estados.
    \item As taxas de homicídio em todos os 50 estados e DC.
    {\color{red} \item O nome do estado, a abreviatura do nome do estado, a região do estado e a população do estado e o número total de assassinatos em 2010.}
    \item \verb|str| não apresenta informações relevantes.
  \end{enumerate}
\end{enumerate}

```{r}
library(dslabs)
data("murders")

str(murders)
```

\begin{enumerate}[resume, leftmargin=*]
  \item Quais são os nomes das colunas usadas pelo \textit{data frame} para essas cinco variáveis?
\end{enumerate}

```{r}
colnames(murders)
```

\begin{enumerate}[resume, leftmargin=*]
  \item Use o acessador \verb|$| para extrair as abreviações de estado e atribuí-las ao objeto \verb|a|. Qual é a classe deste objeto?
\end{enumerate}

```{r}
a <- murders$abb

class(a)
```

\begin{enumerate}[resume, leftmargin=*]
  \item Agora use os colchetes para extrair as abreviações de estado e atribuí-las ao objeto \verb|b|. Use a função \verb|identical| para determinar se \verb|a| e \verb|b| são iguais.
\end{enumerate}

```{r}
b <- murders[['abb']]

identical(a, b)
```

\begin{enumerate}[resume, leftmargin=*]
  \item Vimos que a coluna \verb|region| armazena um fator. Você pode corroborar isso digitando:
\end{enumerate}

```{r}
class(murders$region)
```

\begin{enumerate}[resume, leftmargin=*]
  \item[] Com uma linha de código, use as funções \verb|levels| e \verb|length| para determinar o número de regiões definidas por este conjunto de dados.
\end{enumerate}

```{r}
length(levels(murders$region))
```

\begin{enumerate}[resume, leftmargin=*]
  \item A função \verb|table| pega um vetor e retorna a frequência de cada elemento. Você pode ver rapidamente quantos estados existem em cada região aplicando esta função. Use esta função em uma linha de código para criar uma tabela de estados por região.
\end{enumerate}

```{r}
table(murders$region)
```

\begin{enumerate}[resume, leftmargin=*]
  \item Use a função \verb|c| para criar um vetor com as altas temperaturas médias em janeiro para Pequim, Lagos, Paris, Rio de Janeiro, San Juan e Toronto, que são 35, 88, 42, 84, 81 e 30 graus Fahrenheit. Chame o objeto \verb|temp|.
\end{enumerate}

```{r}
temp <- c(35, 88, 42, 84, 81, 30)
```

\begin{enumerate}[resume, leftmargin=*]
  \item Agora crie um vetor com os nomes das cidades e chame o objeto \verb|city|.
\end{enumerate}

```{r}
city <- c("Pequim", "Lagos", "Paris", "Rio de Janeiro", "San Juan", "Toronto")
```

\begin{enumerate}[resume, leftmargin=*]
  \item Utilize a função \verb|names| e os objetos definidos nos exercícios anteriores para associar os dados de temperatura à sua cidade correspondente.
\end{enumerate}

```{r}
names(temp) <- city

temp
```


\begin{enumerate}[resume, leftmargin=*]
  \item Utilize os operadores \verb|[| e \verb|:| para acessar a temperatura das três primeiras cidades da lista.
\end{enumerate}

```{r}
temp[1:3]
```

\begin{enumerate}[resume, leftmargin=*]
  \item  Use o operador \verb|[| para acessar a temperatura de Paris e San Juan.
\end{enumerate}

```{r}
temp[c("Paris", "San Juan")]
```

\begin{enumerate}[resume, leftmargin=*]
  \item  Use o operador \verb|:| para criar a sequência de números $12, 13, 14, \cdots, 73$.
\end{enumerate}

```{r}
vec <- seq(from=12, to=73)

vec
```

\begin{enumerate}[resume, leftmargin=*]
  \item Crie um vetor contendo todos os números ímpares positivos menores que 100.
\end{enumerate}

```{r}
impares_menores_que_100 <- seq(from=1, to=100, by=2)

impares_menores_que_100
```


\begin{enumerate}[resume, leftmargin=*]
  \item Crie um vetor de números que comece em 6, não passe de 55 e adicione números em incrementos de 4/7: 6, 6 + 4/7, 6 + 8/7 e assim por diante. Quantos números tem a lista? Dica: use \verb|seq| e \verb|length|.
\end{enumerate}

```{r}
vec <- seq(from=6, to=55, by=4/7)

length(vec)
```

\begin{enumerate}[resume, leftmargin=*]
  \item Qual é a classe do seguinte objeto \verb|a <- seq(1, 10, 0.5)|?
\end{enumerate}

```{r}
a <- seq(1, 10, 0.5)

class(a)
```

\begin{enumerate}[resume, leftmargin=*]
  \item Qual é a classe do seguinte objeto \verb|a <- seq(1, 10)|?
\end{enumerate}

```{r}
a <- seq(1, 10)

class(a)
```


\begin{enumerate}[resume, leftmargin=*]
  \item A classe de \verb|class(a<-1)| é numérica, não inteira. O padrão de R é numérico e para forçar um número inteiro, você precisa adicionar a letra \verb|L|. Confirme se a classe de \verb|1L| é inteira.
\end{enumerate}

```{r}
class(1)

class(1L)
```

\begin{enumerate}[resume, leftmargin=*]
  \item Defina o seguinte vetor:
\end{enumerate}

```{r}
x <- c("1", "3", "5")
```

\begin{enumerate}[resume, leftmargin=*]
  \item[] e use coerção para obter números inteiros.
\end{enumerate}

```{r}
x <- as.numeric(x)

x
```

\begin{enumerate}[resume, leftmargin=*]
  \item Para os exercícios \ref{q24} a \ref{q31} usaremos o conjunto de dados de assassinatos nos EUA. Certifique-se de carregá-lo antes de começar. Use o operador \verb|$| para acessar os dados do tamanho da população e armazená-los como objeto \verb|pop|. Em seguida, use a função \verb|sort| para redefinir \verb|pop| para que seja classificado. Finalmente, use o operador \verb|[| para relatar o menor tamanho da população. \label{q24}
\end{enumerate}

```{r}
library("dslabs")

data("murders")

pop <- murders$population

pop <- sort(pop)

pop[1]
```

\begin{enumerate}[resume, leftmargin=*]
  \item Agora, em vez do menor tamanho populacional, encontre o índice da entrada com o menor tamanho populacional. Dica: use \verb|order| em vez de \verb|sort|.
\end{enumerate}

```{r}
indices <- order(murders$population)

i_min <- indices[1]

i_min
```



\begin{enumerate}[resume, leftmargin=*]
  \item Na verdade, podemos realizar a mesma operação do exercício anterior usando a função \verb|which.min|. Escreva uma linha de código que faça isso.
\end{enumerate}

```{r}
i_min <- which.min(murders$population)

i_min
```


\begin{enumerate}[resume, leftmargin=*]
  \item Agora sabemos quão pequeno é o menor estado e qual linha o representa. Qual estado é esse? Defina uma variável \verb|states| para ser os nomes dos estados do \textit{data frame} \verb|murders|. Informe o nome do estado com menor população.
\end{enumerate}

```{r}
states <- murders$state

states[i_min]
```


\begin{enumerate}[resume, leftmargin=*]
  \item Você pode criar um \textit{data frame} usando a função \verb|data.frame|. Aqui está um exemplo rápido:
\end{enumerate}

```{r}
temp <- c(35, 88, 42, 84, 81, 30)
city <- c("Beijing", "Lagos", "Paris", "Rio de Janeiro", "San Juan", "Toronto")

city_temps <- data.frame(name=city, temperature=temp)

```


\begin{enumerate}[resume, leftmargin=*]
  \item[] Use a função \verb|rank| para determinar a classificação da população de cada estado, do menor ao maior tamanho populacional. Salve essas classificações em um objeto chamado \verb|ranks| e crie um \textit{data frame} com o nome do estado e sua classificação. Chame o quadro de dados \verb|my_df|. 
\end{enumerate}

```{r}
ranks <- rank(murders$population)

state <- murders$state

my_df <- data.frame(state, ranks)
my_df
```


\begin{enumerate}[resume, leftmargin=*]
  \item Repita o exercício anterior, mas desta vez ordene \verb|my_df| de forma que os estados sejam ordenados do menos populoso para o mais populoso. Dica: crie um objeto \verb|ind| que armazene os índices necessários para ordenar os valores da população. Em seguida, use o operador de colchetes \verb|[| para reordenar cada coluna no quadro de dados.
\end{enumerate}

```{r}
ind <- order(murders$population)

state <- murders$state

state <- state[ind]
pop <- murders$population

pop <- pop[ind]

my_df <- data.frame(state, pop)

my_df
```


\begin{enumerate}[resume, leftmargin=*]
  \item O vetor \verb|na_example| representa uma série de contagens. Você pode examinar rapidamente o objeto usando:
\end{enumerate}

```{r}
str(na_example)
```

\begin{enumerate}[resume, leftmargin=*]
  \item[]  No entanto, quando calculamos a média com a função mean, obtemos \verb|NA|:
\end{enumerate}

```{r}
mean(na_example)
```

\begin{enumerate}[resume, leftmargin=*]
  \item[] A função \verb|is.na| retorna um vetor lógico que nos informa quais entradas são \verb|NA|. Atribua este vetor lógico a um objeto chamado inde determine quantos NAs \verb|na_example| possui.
\end{enumerate}

```{r}
ind <- is.na(na_example)

sum(ind)
```


\begin{enumerate}[resume, leftmargin=*]
  \item Agora calcule a média novamente, mas apenas para as entradas que não são \verb|NA|. Dica: lembre-se do operador \verb|!|.  \label{q31}
\end{enumerate}

```{r}
mean(na_example[!ind])
```

\begin{enumerate}[resume, leftmargin=*]
  \item  Anteriormente criamos este quadro de dados:
\end{enumerate}

```{r}
temp <- c(35, 88, 42, 84, 81, 30)
city <- c("Beijing", "Lagos", "Paris", "Rio de Janeiro", "San Juan", "Toronto")
city_temps <- data.frame(name = city, temperature = temp)
```


\begin{enumerate}[resume, leftmargin=*]
  \item[] Refaça o quadro de dados usando o código acima, mas adicione uma linha que converta a temperatura de Fahrenheit para Celsius. A conversão é $C = \frac{5}{9} \times \left(F - 32\right)$.
\end{enumerate}

```{r}
temp_f <- c(35, 88, 42, 84, 81, 30)

temp_c <- round((5/9) * (temp_f - 32), 2)

city <- c("Beijing", "Lagos", "Paris", "Rio de Janeiro", "San Juan", "Toronto")
city_temps <- data.frame(name = city, temp_Fahrenheit = temp_f, temp_Celsius = temp_c)

city_temps
```

\begin{enumerate}[resume, leftmargin=*]
  \item Qual é a seguinte soma $ 1 + 1/2^2 + 1/3^2 + \cdots + 1/100^2$? ica: graças a Euler, sabemos que deveria estar próximo de $\pi^2/6$.
\end{enumerate}

```{r}
denominador <- seq(from=1, to=100)

x <- 1 / denominador ^2

sum(x)
```



